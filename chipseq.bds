#!/usr/bin/env bds
#vim: syntax=java


help == chipseq pipeline settings
// general
type 		:= "TF" 	help Type of ChIP-Seq pipeline. TF or histone (default: TF).
histone 	:= false	help (LEGACY PARAM) Histone ChIP-Seq. Equivalent to '-type histone'
final_stage	:= "" 		help Final stage for pipeline (bam, filt_bam, tag, xcor and peak).
// signal track generation
sig_trk_for_pooled_rep_only := false 	help Generate MACS2 signal tracks for pooled replicate only.
// mapping/filtering/aligning
aligner		:= "bwa" 	help Aligner to map raw reads in FASTQs (default: bwa).
subsample_xcor 	:= "15M"	help # reads to be subsampled for cross corr. analysis (default: 15M).
subsample_chip 	:= "0" 		help # reads to subsample exp. replicate. Subsampled tagalign will be used for steps downstream (default: 0; no subsampling).
subsample 	:= "0" 		help (LEGACY PARAM) # reads to subsample exp. replicate. Subsampled tagalign will be used for steps downstream (default: 0; no subsampling).
subsample_ctl 	:= "0" 		help # reads to subsample control if non-zero (recommended: 40M or lower).
anon_filt_bam 	:= false 	help Generate an annomymized filtered bam. This will not affect tasks downsteam.
// peak calling
peak_caller 	:= "spp"  	help Peak caller for IDR analysis (default: spp for TF ChIP-seq and macs2 for Histone ChIP-seq ).
ctl_depth_ratio := 1.2 		help Cut-off ratio of two control tagaligns for pooling (default: 1.2).
fraglen 	:= 0 		help (LEGACY PARAM) Manually specify fragment length (default: 0, 0 means parsing fraglen from cross-corr analysis log file).
idr_rank 	:= ""  		help Scoring column in narrow peak files for IDR. If not specified, signal.value for SPP peaks (TF) and p.value for MACS2 peaks (histone) are used.
idr_thresh 	:= 0.05		help IDR threshold : -log_10(score) (default: 0.05).
use_pooled_ctl 	:= false 	help Force to use pooled control (ignoring criteria to choose control for each replicate).
true_rep   	:= false	help Call peaks on true replicates only.
no_pseudo_rep	:= false 	help Do not call peaks on self pseudo replicates.
no_xcor 	:= false 	help Disable cross-correlation analysis.
no_gpeak_filt 	:= false 	help Disable gapped peak filtering through narrow peak (for histone ChIP-Seq only).
no_browser_tracks := false 	help Disable generation of genome browser tracks (workaround for bzip2 shared library issue).
pe_xcor_only 	:= false 	help (PE ONLY) Align R1 of paired end fastqs only and for cross-correlation analysis. All other analyses and QCs will be disabled.
pe_no_trim_fastq := false 	help (PE ONLY) No fastq trimming and use PE tagAlign for cross-correlation analysis.
disable_gb_peak := true // disable gapped/broad peak generation

help() // print help and exit if no parameters are given

include "modules/pipeline_template.bds"

include "modules/input.bds"

include "modules/align_bwa.bds"
include "modules/align_trim_fastq.bds"
include "modules/postalign_bam.bds"
include "modules/postalign_bed.bds"
include "modules/postalign_xcor.bds"

include "modules/callpeak_spp.bds"
include "modules/callpeak_gem.bds"
include "modules/callpeak_peakseq.bds"
include "modules/callpeak_macs2_chipseq.bds"
include "modules/callpeak_naive_overlap.bds"
include "modules/callpeak_idr.bds"
include "modules/callpeak_blacklist_filter.bds"

//include "modules/signal.bds"

// Important file names are stored in global variables (usually a string map string{} with a key with replicate id and peakcaller name)
// e.g. filt_bam{"Replicate 1"} = filtered bam for replicate 1, peak_pr1{"spp,2"} = peak file for pseudo replicate 1 of replicate 2 generated from spp

string{} flagstat_qc, dup_qc, flagstat_nodup_qc, pbc_qc, xcor_qc, xcor_plot, jsd_qc
string{} bam, filt_bam

string jsd_png

string{} tag, tag_pr1, tag_pr2
string tag_ppr1, tag_ppr2

string{} peak, peak_pr1, peak_pr2, peak_pooled, peak_ppr1, peak_ppr2
string{} gpeak, gpeak_pr1, gpeak_pr2, gpeak_pooled, gpeak_ppr1, gpeak_ppr2
string{} bpeak, bpeak_pr1, bpeak_pr2, bpeak_pooled, bpeak_ppr1, bpeak_ppr2
// string peak_overlap, gpeak_overlap, bpeak_overlap

string{} raw_peak_qc_FRiP

string{} idr_tr, idr_pr, idr_tr_png, idr_pr_png
string idr_ppr, idr_opt, idr_consv, idr_ppr_png
string idr_qc
string{} idr_qc_FRiP

string{} peak_overlap_tr, peak_overlap_pr
string peak_overlap_ppr, peak_overlap_opt, peak_overlap_consv
string peak_overlap_qc
string{} peak_overlap_qc_FRiP

string{} sig_trk 	 	// signal tracks from deepTools or bamCoverage: map with key ("$ctl,$rep")
string{} pval_bigwig, fc_bigwig // signal track from macs2
string num_peak_log


main()


void main() { // chipseq pipeline starts here

	init_chipseq() // read command line parameters or configruation file
	chk_param() // check if parameters are valid
	chk_input( true_rep, no_pseudo_rep ) // if inputs are fastq, bam, or tagalign, check if they exist

	align() // align and postalign
	jsd() // plot fingerprint and compute synthetic JS distance

	if ( !pe_xcor_only ) {
		pool_tags() // make pooled tagaligns and choose appropriate control for each replicate
		call_peaks() // call peaks in parallel (MACS2,SPP)
		read_input_peak() // if inputs are peaks, read them
		naive_overlap() // get naive overlap peaks
		log_number_of_peaks()
		do_idr() // IDR
		filter_peak() // blacklist-filter peaks
	}
	report()
}

void init_chipseq() {
	read_conf_chipseq()
	init_filetable()
}

void read_conf_chipseq() {
	type		= get_conf_val( type,			["type"] )
	histone 	= get_conf_val_bool( histone, 		["histone"] )
	if ( histone ) type = "histone" // backward compatibility for LEGACY param
	if ( type == "histone" && !cmd_line_arg_has_key("peak_caller") ) peak_caller = "macs2"
	final_stage	= get_conf_val( final_stage, 		["final_stage"] )
	sig_trk_for_pooled_rep_only = get_conf_val_bool( sig_trk_for_pooled_rep_only, 	["sig_trk_for_pooled_rep_only"] )
	aligner 	= get_conf_val( aligner, 		["aligner"] )
	subsample_xcor 	= get_conf_val( subsample_xcor,		["subsample_xcor"] )
	subsample_chip 	= get_conf_val( subsample_chip,		["subsample_chip"] )
	subsample 	= get_conf_val( subsample,		["subsample"] )
	subsample_ctl 	= get_conf_val( subsample_ctl,		["subsample_ctl"] )
	anon_filt_bam 	= get_conf_val_bool( anon_filt_bam, 	["anon_filt_bam"] )
	peak_caller	= get_conf_val( peak_caller, 		["peak_caller"] )
	ctl_depth_ratio = get_conf_val_real( ctl_depth_ratio, 	["ctl_depth_ratio"])		
	fraglen 	= get_conf_val_int( fraglen, 		["fraglen"] )
	idr_rank 	= get_conf_val( idr_rank, 		["idr_rank"] )
	idr_thresh 	= get_conf_val_real( idr_thresh, 	["idr_thresh"] )
	use_pooled_ctl 	= get_conf_val_bool( use_pooled_ctl, 	["use_pooled_ctl"] )
	true_rep 	= get_conf_val_bool( true_rep, 		["true_rep"] )
	no_pseudo_rep	= get_conf_val_bool( no_pseudo_rep, 	["no_pseudo_rep"] )
	no_xcor		= get_conf_val_bool( no_xcor, 		["no_xcor"] )
	no_gpeak_filt	= get_conf_val_bool( no_gpeak_filt, 	["no_gpeak_filt"] )
	no_browser_tracks = get_conf_val_bool( no_browser_tracks,	["no_browser_tracks"] )
	pe_xcor_only = get_conf_val_bool( pe_xcor_only,	["pe_xcor_only"] )
	pe_no_trim_fastq = get_conf_val_bool( pe_no_trim_fastq,	["pe_no_trim_fastq"] )

	check_peak_caller_valid()		
	check_aligner_valid()		
	if ( pe_xcor_only ) final_stage = "xcor"
	if ( idr_rank == "" ) {
		if ( peak_caller == "spp" || peak_caller == "gem" ) {
			idr_rank = "signal.value"
		}
		else if ( peak_caller == "macs2" ) {
			idr_rank = "p.value"
		}
		else if ( peak_caller == "peakseq" ) {
			idr_rank = "q.value"
		}
		else error("Unsupported peak_caller ($peak_caller)!")

		idr_rank = (peak_caller == "spp" ? "signal.value" : "p.value")
	}
	// for backward compatibility for legacy params
	if ( subsample_chip == "0" && subsample != "0" ) subsample_chip = subsample
	if ( extsize_macs2 == -1 && fraglen > 0 ) extsize_macs2 = fraglen
	if ( speak_spp == -1 && fraglen > 0 ) speak_spp = fraglen
	if ( is_final_stage_after_xcor() && no_xcor ) {
		if ( speak_spp == -1 ) error("For the case of no cross-corr. analysis (-no_xcor). You need to specify -speak_spp.")
		if ( extsize_macs2 == -1 ) error("For the case of no cross-corr. analysis (-no_xcor). You need to specify -extsize_macs2.")
	}
	peak_caller = peak_caller.toLower()

	print( "\n\n== chipseq pipeline settings\n")
	print( "# replicates \t\t\t\t: "+get_num_rep()+"\n" )
	print( "Type of ChIP-Seq pipeline\t\t: $type\n")
	print( "Final stage for ChIP-Seq\t\t: $final_stage\n" )
	print( "Signal tracks for pooled rep. only\t: $sig_trk_for_pooled_rep_only\n")
	print( "Aligner to map raw reads\t\t\t: $aligner\n")
	print( "# reads to subsample for cross-corr. analysis\t\t: "+parse_number( subsample_xcor)+"\n")
	print( "# reads to subsample exp. replicates (0: no subsampling): "+parse_number( subsample_chip )+"\n")
	print( "# reads to subsample controls (0: no subsampling)\t: "+parse_number( subsample_ctl)+"\n")
	print( "Generate anonymized filt. bam\t\t: $anon_filt_bam\n")
	print( "Peak caller for IDR analysis\t\t: $peak_caller\n")
	print( "Control rep. depth ratio\t\t: $ctl_depth_ratio\n" )
	// print( "Specified fraglen (0:auto)\t\t: $fraglen\n")
	print( "Scoring column for IDR\t\t\t: $idr_rank\n")
	print( "IDR threshold\t\t\t\t: $idr_thresh\n" )
	print( "Force to use pooled ctl\t\t\t: $use_pooled_ctl\n")
	print( "Peak calling for true reps only\t\t: $true_rep\n" )
	print( "No peak calling for self pseudo reps\t: $no_pseudo_rep\n" )
	print( "Disable cross-correlation analysis\t: $no_xcor\n" )
	print( "Disable g. peak filt. thru. n. peak\t: $no_gpeak_filt\n" )
	print( "Disable genome browser tracks\t: $no_browser_tracks\n" )	
	print( "Disable all QCs except cross-corr. (PE only)\t: $pe_xcor_only\n" )
	print( "No fastq trimming and use PE tagAlign for cross-corr. (PE only)\t: $pe_no_trim_fastq\n" )
}

void init_filetable() { // init file table labels in HTML report

	// add label to graphviz
	// : Items in filetable will be sorted in the ascending order of rank
 	// : Items added later will have higher rank

	// Level 1
	add_label_to_table("Raw reads")
	add_label_to_table("Alignment")
	add_label_to_table("Signal tracks")
	add_label_to_table("Peaks")
	add_label_to_table("QC and logs")

	// Level 2
	for (int i=1; i<=100; i++) \
		add_label_to_table("Replicate $i")
	for (int i=1; i<=100; i++) \
		add_label_to_table("Control $i")
	
	add_label_to_table("True replicates")
	add_label_to_table("Pooled replicate")
	add_label_to_table("Pooled control")
	add_label_to_table("Pseudo-replicates")
	add_label_to_table("Pooled pseudo-replicate")
	add_label_to_table("Pooled pseudo-replicates")
	add_label_to_table("Optimal set")
	add_label_to_table("Conservative set")
	add_label_to_table("Naive overlap")
	add_label_to_table("SPP")
	add_label_to_table("MACS2")
	add_label_to_table("IDR")

	// Level 2 or 3
	add_label_to_table("Pseudo-replicate 1")
	add_label_to_table("Pseudo-replicate 2")
	add_label_to_table("Pooled pseudo-replicate 1")
	add_label_to_table("Pooled pseudo-replicate 2")
	for (int i=1; i<=20; i++) \
	    for (int j=i+1; j<=20; j++) \
	        add_label_to_table("Rep. $i vs Rep. $j")

	// Higher levels
	add_label_to_table("IDR QC")
	add_label_to_table("Fastq")
	add_label_to_table("Fastq 1")
	add_label_to_table("Fastq 2")
	add_label_to_table("BWA map. flagstat log")
	add_label_to_table("Bam")
	add_label_to_table("Filtered bam")
	add_label_to_table("Sorted bam")
	add_label_to_table("Dedup. log")
	add_label_to_table("Map. flagstat log")
	add_label_to_table("PBC log")
	add_label_to_table("Bedpe")
	add_label_to_table("Subsampled bedpe")
	add_label_to_table("Tag-align")
	add_label_to_table("Subsampled tag-align")
	add_label_to_table("Cross-corr. log")
	add_label_to_table("Cross-corr. plot")
	add_label_to_table("P-value")
	add_label_to_table("Fold enrichment")
	add_label_to_table("Narrow peak")
	add_label_to_table("Region peak")
	add_label_to_table("Broad peak")
	add_label_to_table("Gapped peak")
	add_label_to_table("IDR peak")
	add_label_to_table("Peak")
	add_label_to_table("Filtered peak")
	add_label_to_table("Filtered gapped peak")
	add_label_to_table("Filtered broad peak")
	add_label_to_table("IDR plot")
	add_label_to_table("Unthresholded IDR peak")

	// add label to graphviz (short name, long name)

	for (int i=1; i<=50; i++) {
		add_label_to_graph("rep$i", "Replicate $i")
		add_label_to_graph("rep$i-pr1", "Pseudo-replicate 1 for rep. $i")
		add_label_to_graph("rep$i-pr2", "Pseudo-replicate 2 for rep. $i")
		add_label_to_graph("rep$i-pr", "Pseudo replicates for rep. $i")
		for (int j=1; j<=20; j++) {
			add_label_to_graph("rep$i-rep$j", "Rep. $i vs. Rep. $j")
		}
	}
	for (int i=1; i<=100; i++) {
		add_label_to_graph("ctl$i", "Control $i")
	}
	add_label_to_graph("pooled_rep", "Pooled replicate")
	add_label_to_graph("pooled_ctl", "Pooled control")
	add_label_to_graph("ppr", "Pooled pseudo-replicates")
	add_label_to_graph("ppr1", "Pooled pseudo-replicate 1")
	add_label_to_graph("ppr2", "Pooled pseudo-replicate 2")
}

void chk_param() {

	print( "\n\n== checking chipseq parameters ...\n" )
	if ( pe_xcor_only && !is_input_fastq(0,1) ) {
		error("-pe_xcor_only is for fastqs only!\n")
	}
	if ( has_input_fastq() ) 	chk_align_bwa()	
	if ( is_final_stage_idr() ) 	chk_idr()
	if ( is_final_stage_idr() || is_final_stage_peak() ) chk_callpeak_macs2()

	// errors
	if ( peak_caller == "gem" ) chk_callpeak_gem()
	if ( peak_caller == "peakseq" ) chk_callpeak_peakseq()
	if ( !is_input_peak() && peak_caller == "spp" && !ctl_exists() && !is_final_stage_before_peak() ) \
		error("Cannot call peaks (SPP) without controls!\n")

	if ( multimapping > 0 ) \
		error("Multimapping is not available for chipseq pipeline!\n")

	if ( is_input_peak() && true_rep && get_num_rep() == 1 && is_TF_chipseq() ) \
		error("Cannot perform IDR on with only one replicate when '-true_rep' is turned on!")

	// if ( is_histone_chipseq() && sig_trk_for_pooled_rep_only ) \
	// 	sig_trk_for_pooled_rep_only = false

	if ( has_pe_input_tag() && parse_number( subsample_xcor ) > 0 ) \
		print("Warning: PE tagaligns cannot be subsampled for cross-corr. analysis.\n")

	if ( has_pe_input_tag() && parse_number( subsample_chip ) > 0 ) \
		print("Warning: PE tagaligns cannot be subsampled!\n")

	if ( has_pe_input_tag(1) && parse_number( subsample_ctl ) > 0 ) \
		error("PE contol tagaligns cannot be subsampled!\n")

	// if ( sig_trk_for_pooled_rep_only && macs2_for_idr ) \
	// 	error("-sig_trk_for_pooled_rep_only and -macs2_for_idr are mutally exclusive parameters!\n")
}

void align() {
	if ( is_input_peak() ) return

	// distribute # of threads to each replicate/control according to their file sizes
	// different weight for each data type 3 for fastq, 5 for tagaligns, 1 for others

	int{} filesize

	for ( int ctl=0; ctl <= 1; ctl++) { // iterate through inputs (ctl==0 : exp. replicate, ctl==1 : control)
		if ( ctl==1 && !ctl_exists() ) continue

		for ( int rep=1; rep <= get_num_rep( ctl ); rep++) {		
			if ( !input_file_exists( ctl, rep ) ) continue

			// check file size to distribute_nonzero nth to each nth_app
			// determine # threads for each app related to alignment

			group := get_group_name( ctl, rep )

			// get file size in bytes
			if ( is_input_fastq( ctl, rep ) ) {

				fastqs := get_fastqs( ctl, rep )
				filesize{group} = (fastqs[0]).size()*3 // multiply 3 (weight) to allocate more cpus for align
				if ( fastqs.size() > 1) filesize{group} += (fastqs[1]).size()
			}
			else if ( is_input_bam( ctl, rep ) ) 		filesize{group} = (get_bam( ctl, rep )).size()
			else if ( is_input_filt_bam( ctl, rep ) ) 	filesize{group} = (get_filt_bam( ctl, rep )).size()
			else if ( is_input_tag( ctl, rep ) ) 		filesize{group} = (get_tag( ctl, rep )).size()*5
		}
	}

	nth_rep := distribute_nonzero( nth, filesize )

	// align
	
	for ( int ctl=0; ctl <= 1; ctl++) { // iterate through inputs (ctl==0 : exp. replicate, ctl==1 : control)
		if ( ctl==1 && !ctl_exists() ) continue		

		for ( int rep=1; rep <= get_num_rep( ctl ); rep++) {

			if ( !input_file_exists( ctl, rep ) ) continue

			group := get_group_name( ctl, rep )

			if ( no_par ) align( ctl, rep, nth_rep{group} ) // parallel jobs for align() for each replicate and each control
			else	  par align( ctl, rep, nth_rep{group} ) // parallel jobs for align() for each replicate and each control
		}
	}
	wait

	print( "\n== Done align()\n" )
}

void jsd() { // plot fingerprint
	if ( filt_bam.hasKey("ctl1") && filt_bam.hasKey("rep1") ) {
		nth_sam_idx := min(2,nth)

		string[] filt_bams, labels
		for ( int rep=1; rep <= get_num_rep( 0 ); rep++) { // IP replicate
			group := get_group_name( 0, rep )
			filt_bam_ := filt_bam{group}
			filt_bams.add(filt_bam_)
			labels.add(group)

			samtools_index(filt_bam_, group, nth_sam_idx)
		}
		group_ctl1 := get_group_name( 1, 1 ) // 1st control replicate

		ctl_filt_bam1 := filt_bam{group_ctl1}
		labels.add(group_ctl1)

		samtools_index(ctl_filt_bam1, group_ctl1, nth_sam_idx)
		wait

		nth_jsd := min(4,nth)

		string jsd_qc_all_reps
		(jsd_png, jsd_qc_all_reps) = \
			jsd(filt_bams, ctl_filt_bam1, labels, "$out_dir/qc", nth_jsd )
		wait
		// get each line in jsd_qc_all_reps and save to individual qc file for each rep
		lines := jsd_qc_all_reps.readLines()
		for ( int rep=1; rep <= get_num_rep( 0 ); rep++) { // IP replicate
			arr := lines[rep].trim().split("\t")
			string[] arr_without_col_1 // remove sample name from log file
			for ( int i=1; i < arr.size(); i++) {
				arr_without_col_1.add(arr[i])
			}
			group := get_group_name( 0, rep )
			long := get_long_group_name( 0, rep )
			filt_bam_ := filt_bam{group}

			prefix := replace_dir( rm_ext( filt_bam_, "bam" ), "$out_dir/qc/rep$rep" )
			jsd_qc_ := "$prefix.jsd.qc"
			if ( jsd_qc_ <- jsd_qc_all_reps ) {
				jsd_qc_.write( arr_without_col_1.join("\t") )
			}
			jsd_qc{group} = jsd_qc_
			add_file_to_table( jsd_qc_, "QC and logs/$long/JS Distance" )
		}
		// jsd_qc_all_reps.rm()
		add_file_to_table( jsd_png, "QC and logs/Fingerprint JSD Plot")

		print( "\n== Done jsd()\n" )
	}
}

void align( int ctl, int rep, int nth_rep ) {

	if ( is_se( ctl, rep ) ) {
		align_SE( ctl, rep, nth_rep )
	}
	else {
		align_PE( ctl, rep, nth_rep )
	}
}

void align_SE( int ctl, int rep, int nth_rep ) {
	// ctl==0: exp. replicate, ctl==1: control

	group 	:= get_group_name( ctl, rep )
	long 	:= get_long_group_name( ctl, rep )

	aln_o_dir := mkdir( "$out_dir/align/$group" ) // create align output directory
	qc_o_dir  := mkdir( "$out_dir/qc/$group" ) // create qc output dir.

	string bam_, flagstat_qc_
	string mapped_reads // read count

	if ( is_input_fastq( ctl, rep ) ) {

		fastqs := get_fastqs( ctl, rep )

		// pool if multiple fastqs
		string pooled_fastq
		if ( fastqs.size()==1 ) pooled_fastq = fastqs[0]
		else {
			pooled_fastq = pool_fastq( fastqs, aln_o_dir, group )
			wait
		}
		if ( aligner == "bwa" ) {
			( bam_, flagstat_qc_ ) = bwa( pooled_fastq, aln_o_dir, qc_o_dir, group, nth_rep )
		}
		else {
			error("Unsupported aligner ($aligner)!")
		}
		bam{group} = bam_
		flagstat_qc{group} = flagstat_qc_
		add_file_to_table( flagstat_qc_, "QC and logs/$long/BWA map. flagstat log")
		wait
		// parse read counts
		tmp_log := parse_flagstat( flagstat_qc_ )
		raw_reads := metric_prefix( parse_int( tmp_log{"total"} ) )
		mapped_reads = metric_prefix( parse_int( tmp_log{"mapped"} ) )

		// apply read counts to report
		if ( fastqs.size()==1 ) {
			add_file_to_report( fastqs[0], "fastq\\n$raw_reads", group, "Raw reads/$long/Fastq ($raw_reads)" )
		}
		else {			
			for ( int i=0; i<fastqs.size(); i++) {
				id := i+1
				suffix := ":$id"
				add_file_to_report( fastqs[i], "fastq$suffix", group, "Raw reads/$long/Fastq$suffix" )
			}
			add_file_to_report( pooled_fastq, "pooled\\nfastq\\n$raw_reads", group, \
						"Raw reads/$long/Pooled fastq ($raw_reads)" )
		}
	}
	wait

	string filt_bam_, dup_qc_, pbc_qc_, flagstat_nodup_qc_
	string deduped_reads

	if ( is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {
	
		if ( is_input_bam( ctl, rep ) ) bam_ = get_bam( ctl, rep )
		
		add_file_to_report( bam_, "bam" + (mapped_reads ? "\\n$mapped_reads" : ""), group, \
			"Alignment/$long/Bam" + (mapped_reads ? " ($mapped_reads)" : "") )

		if ( is_final_stage_bam() ) return

		if ( no_dup_removal ) {
			string tmp
			( filt_bam_, tmp ) \
				= dedup_bam( bam_, aln_o_dir, qc_o_dir, group, nth_rep )
			wait
		}
		else {
			( filt_bam_, dup_qc_, flagstat_nodup_qc_, pbc_qc_ ) \
				= dedup_bam( bam_, aln_o_dir, qc_o_dir, group, nth_rep )			
			dup_qc{group} = dup_qc_
			add_file_to_table( dup_qc_, "QC and logs/$long/Dedup. log")
			pbc_qc{group} = pbc_qc_
			add_file_to_table( pbc_qc_, "QC and logs/$long/PBC log")
			flagstat_nodup_qc{group} = flagstat_nodup_qc_
			add_file_to_table( flagstat_nodup_qc_, "QC and logs/$long/Filtered flagstat log")
			wait
			// add to report
			tmp_log := parse_flagstat( flagstat_nodup_qc_ )
			deduped_reads = metric_prefix( parse_int( tmp_log{"total"} ) )
		}
	}

	string tag_

	if ( is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_filt_bam( ctl, rep ) ) filt_bam_ = get_filt_bam( ctl, rep )

		add_file_to_report( filt_bam_, "filt. bam" + (deduped_reads ? "\\n$deduped_reads" : ""), group, \
			"Alignment/$long/Filtered & deduped bam" + (deduped_reads ? " ($deduped_reads)" : "") )

		filt_bam{group} = filt_bam_

		if ( anon_filt_bam ) anonymize_filt_bam( filt_bam_, aln_o_dir, group )

		if ( is_final_stage_filt_bam() ) return

		tag_ = bam_to_tag( filt_bam_, aln_o_dir, group )
		wait
	}

	if ( is_input_tag( ctl, rep ) || is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {

		if ( is_input_tag( ctl, rep ) ) tag_ = get_tag( ctl, rep )

		add_file_to_report( tag_, "tag-align", group, "Alignment/$long/Tag-align" )

		if ( ctl == 0 && parse_number( subsample_chip ) > 0 ) {
			tag_ = subsample_tag( tag_, parse_number( subsample_chip ), false, aln_o_dir, group )
			wait
		}
		else if ( ctl > 0 && parse_number( subsample_ctl ) > 0 ) {
			tag_ = subsample_tag( tag_, parse_number( subsample_ctl ), false, aln_o_dir, group )
			wait
		}

		tag{group} = tag_

		if ( is_final_stage_tag() ) return

		string xcor_qc_

		if ( ctl == 0 ) { // if replicate

			if ( !true_rep ) { // pseudo replicates
				aln_pr1_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr1" )
				aln_pr2_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr2" )

				string tag_pr1_, tag_pr2_
				(tag_pr1_, tag_pr2_ ) = spr( tag_, aln_pr1_o_dir, aln_pr2_o_dir, group ) // make self pseudo replicate
				tag_pr1{group} = tag_pr1_
				tag_pr2{group} = tag_pr2_
				add_file_to_report( tag_pr1_, "tag-align", "$group-pr1", \
							"Alignment/Pseudo-replicates/$long/Pseudo-replicate 1/Tag-align" )
				add_file_to_report( tag_pr2_, "tag-align", "$group-pr2", \
							"Alignment/Pseudo-replicates/$long/Pseudo-replicate 2/Tag-align" )
			}
			// wait

			if ( !no_xcor ) {
				subsampled_tag_xcor := subsample_tag( tag_, parse_number( subsample_xcor ), true, aln_o_dir, group )
				wait
				// xcor for true rep
				string xcor_qc_, xcor_plot_
				( xcor_qc_, xcor_plot_ ) = xcor( subsampled_tag_xcor, qc_o_dir, group, nth_rep )

				xcor_qc{group} = xcor_qc_
				xcor_plot{group} = xcor_plot_

				add_file_to_report( xcor_qc_, "xcor log", group, "QC and logs/$long/Cross-corr. log" )
				add_file_to_table( xcor_plot_, "QC and logs/$long/Cross-corr. plot" )
			}
		}

		if ( is_final_stage_xcor() ) return
	}	
}

void align_PE( int ctl, int rep, int nth_rep ) {
	if ( pe_xcor_only && ctl > 0 ) return
	// ctl==0: exp. replicate, ctl==1: control

	group 	:= get_group_name( ctl, rep )
	long 	:= get_long_group_name( ctl, rep )

	aln_o_dir := mkdir( "$out_dir/align/$group" ) // create align output directory
	qc_o_dir  := mkdir( "$out_dir/qc/$group" ) // create qc output dir.

	string bam_, flagstat_qc_, bam_R1
	string mapped_reads // read count

	string tmp
	if ( is_input_fastq( ctl, rep ) ) {

		fastqs_pair1 := get_fastq( ctl, rep, 1 )
		string[] fastqs_pair2
		if ( !pe_xcor_only ) {
			fastqs_pair2 = get_fastq( ctl, rep, 2 )
			if ( fastqs_pair1.size() != fastqs_pair2.size() ) {
				error("Number of fastqs to be pooled for pair 1 and pair 2 do not match!\n")
			}
		}

		string pooled_fastq_pair1, pooled_fastq_pair2
		if ( fastqs_pair1.size()==1 ) {
			pooled_fastq_pair1 = fastqs_pair1[0]
			if ( !pe_xcor_only ) {
				pooled_fastq_pair2 = fastqs_pair2[0]
			}
		}
		else {
			pooled_fastq_pair1 = pool_fastq( fastqs_pair1, aln_o_dir, group )
			if ( !pe_xcor_only ) {
				pooled_fastq_pair2 = pool_fastq( fastqs_pair2, aln_o_dir, group )
			}
			wait
		}

		// allocate cpu for bwa_SE and bwa_PE
		int[] nth_map 
		if ( !pe_xcor_only ) {
			nth_map = distribute_nonzero( nth_rep, [1,2] )
		}
		else {
			nth_map = [nth_rep]
		}
		// align on R1 fastq
		if ( ctl==0 && !pe_no_trim_fastq ) {
			trimmed_fastq_R1 := trim_fastq( pooled_fastq_pair1, aln_o_dir, group )
			add_file_to_report( trimmed_fastq_R1, "trim. fastq R1", group, "Raw reads/$long/Trimmed fastq R1" )
			wait
			( bam_R1, tmp ) \
				= bwa( trimmed_fastq_R1, aln_o_dir, qc_o_dir, group, nth_map[0] )
			add_file_to_report( bam_R1, "bam R1", group, "Alignment/$long/Bam R1" )
		}

		if ( !pe_xcor_only ) {
			if ( aligner == "bwa" ) {
				( bam_, flagstat_qc_ ) \
					= bwa_PE( pooled_fastq_pair1, pooled_fastq_pair2, aln_o_dir, qc_o_dir, group, nth_map[1] )
			}		
			else {
				error("Unsupported aligner ($aligner)!")
			}
			bam{group} = bam_
			flagstat_qc{group} = flagstat_qc_
			add_file_to_table( flagstat_qc_, "QC and logs/$long/BWA map. flagstat log")
			wait

			// parse read counts
			tmp_log := parse_flagstat( flagstat_qc_ )
			raw_reads := metric_prefix( parse_int( tmp_log{"total"} ) )
			half_raw_reads := metric_prefix( parse_int( tmp_log{"total"} )/2 )
			mapped_reads = metric_prefix( parse_int( tmp_log{"mapped"} ) )

			// apply read counts to report
			if ( fastqs_pair1.size()==1 ) {
				add_file_to_report( fastqs_pair1[0], "fastq1\\n$half_raw_reads", group, \
					"Raw reads/$long/Fastq 1 ($half_raw_reads)" )
				add_file_to_report( fastqs_pair2[0], "fastq2\\n$half_raw_reads", group, \
					"Raw reads/$long/Fastq 2 ($half_raw_reads)" )
			}
			else {
				for ( int i=0; i<fastqs_pair1.size(); i++) {
					id := i+1
					suffix := ":$id"
					add_file_to_report( fastqs_pair1[i], "fastq$suffix", group, "Raw reads/$long/Fastq 1$suffix" )
					add_file_to_report( fastqs_pair2[i], "fastq$suffix", group, "Raw reads/$long/Fastq 2$suffix" )
				}
				add_file_to_report( pooled_fastq_pair1, "pooled\\nfastq1\\n$raw_reads", group, \
							"Raw reads/$long/Pooled fastq 1 ($raw_reads)" )			
				add_file_to_report( pooled_fastq_pair2, "pooled\\nfastq2\\n$raw_reads", group, \
							"Raw reads/$long/Pooled fastq 2 ($raw_reads)" )			
			}
		}
	}
	wait

	string filt_bam_, dup_qc_, pbc_qc_, flagstat_nodup_qc_, filt_bam_R1
	string deduped_reads

	if ( is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {
		if ( bam_R1 && ctl==0 ) {
			( filt_bam_R1, tmp ) \
				= dedup_bam( bam_R1, aln_o_dir, qc_o_dir, group, pe_xcor_only ? nth_rep : 1 )
			add_file_to_report( filt_bam_R1, "filt. bam R1", group, "Alignment/$long/Bam R1" )
		}

		if ( !pe_xcor_only ) {

			if ( is_input_bam( ctl, rep ) ) bam_ = get_bam( ctl, rep )

			add_file_to_report( bam_, "bam" + (mapped_reads ? "\\n$mapped_reads" : ""), group, \
				"Alignment/$long/Bam" + (mapped_reads ? " ($mapped_reads)" : "") )

			if ( is_final_stage_bam() ) return

			if ( no_dup_removal ) {
				( filt_bam_, tmp ) \
					= dedup_bam_PE( bam_, aln_o_dir, qc_o_dir, group, nth_rep )
				wait
			}
			else {
				( filt_bam_, dup_qc_, flagstat_nodup_qc_, pbc_qc_ ) \
					= dedup_bam_PE( bam_, aln_o_dir, qc_o_dir, group, nth_rep )			
				dup_qc{group} = dup_qc_
				add_file_to_table( dup_qc_, "QC and logs/$long/Dedup. log")
				pbc_qc{group} = pbc_qc_
				add_file_to_table( pbc_qc_, "QC and logs/$long/PBC log")
				flagstat_nodup_qc{group} = flagstat_nodup_qc_
				add_file_to_table( flagstat_nodup_qc_, "QC and logs/$long/Filtered flagstat log")
				wait
				// add to report
				tmp_log := parse_flagstat( flagstat_nodup_qc_ )
				deduped_reads = metric_prefix( parse_int( tmp_log{"total"} ) )
			}
		}
	}

	string tag_, bedpe, tag_R1
	
	if ( is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {
		if ( filt_bam_R1 && ctl==0 ) {
			tag_R1 = bam_to_tag( filt_bam_R1, aln_o_dir, group )
			add_file_to_report( tag_R1, "tag-align-R1", group, "Alignment/$long/Tag-align R1" )
		}

		if ( !pe_xcor_only ) {
			if ( is_input_filt_bam( ctl, rep ) ) filt_bam_ = get_filt_bam( ctl, rep )

			add_file_to_report( filt_bam_, "filt. bam" + (deduped_reads ? "\\n$deduped_reads" : ""), group, \
				"Alignment/$long/Filtered & deduped bam" + (deduped_reads ? " ($deduped_reads)" : "") )

			filt_bam{group} = filt_bam_

			if ( anon_filt_bam ) anonymize_filt_bam( filt_bam_, aln_o_dir, group )

			if ( is_final_stage_filt_bam() ) return

			bedpe = bam_to_bedpe( filt_bam_, aln_o_dir, group )
			wait
			add_file_to_graph( bedpe, "bedpe", group )

			tag_ = bedpe_to_tag( bedpe, aln_o_dir, group )
			wait
		}
	}

	if ( is_input_tag( ctl, rep ) || is_input_filt_bam( ctl, rep ) || is_input_bam( ctl, rep ) || is_input_fastq( ctl, rep ) ) {
		if ( !pe_xcor_only ) {
			if ( is_input_tag( ctl, rep ) ) tag_ = get_tag( ctl, rep )

			add_file_to_report( tag_, "tag-align", group, "Alignment/$long/Tag-align" )

			if ( ctl == 0 && parse_number( subsample_chip ) > 0 ) {
				tag_ = subsample_tag_PE( tag_, parse_number( subsample_chip ), false, aln_o_dir, group )
				wait
			}
			else if ( ctl > 0 && parse_number( subsample_ctl ) > 0 ) {
				tag_ = subsample_tag_PE( tag_, parse_number( subsample_ctl ), false, aln_o_dir, group )
				wait
			}

			tag{group} = tag_

			if ( is_final_stage_tag() ) return

			if ( ctl == 0 ) { // if replicate

				if ( !true_rep ) { // if replicate
					aln_pr1_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr1" )
					aln_pr2_o_dir := mkdir( "$out_dir/align/pseudo_reps/$group/pr2" )

					string tag_pr1_, tag_pr2_
					( tag_pr1_, tag_pr2_ ) = spr_tag_PE( tag_, aln_pr1_o_dir, aln_pr2_o_dir, group )
					tag_pr1{group} = tag_pr1_
					tag_pr2{group} = tag_pr2_
					add_file_to_report( tag_pr1_, "tag-align", "$group-pr1", \
								"Alignment/Pseudo-replicates/$long/Pseudo-replicate 1/Tag-align" )
					add_file_to_report( tag_pr2_, "tag-align", "$group-pr2", \
								"Alignment/Pseudo-replicates/$long/Pseudo-replicate 2/Tag-align" )
				}
			}
			// wait
		}
		if ( !no_xcor && ctl==0 ) {
			string subsampled_tag_xcor
			if ( tag_R1 ) {
				subsampled_tag_xcor = subsample_tag( tag_R1, parse_number( subsample_xcor ), true, aln_o_dir, group )
			}
			else {
				subsampled_tag_xcor = subsample_tag_PE_for_xcor( tag_, parse_number( subsample_xcor ), true, aln_o_dir, group )
			}			
			wait

			string xcor_qc_, xcor_plot_
			( xcor_qc_, xcor_plot_ ) = xcor( subsampled_tag_xcor, qc_o_dir, group, nth_rep )

			xcor_qc{group} = xcor_qc_
			xcor_plot{group} = xcor_plot_

			add_file_to_report( xcor_qc_, "xcor log", group, "QC and logs/$long/Cross-corr. log" )
			add_file_to_table( xcor_plot_, "QC and logs/$long/Cross-corr. plot" )
		}

		if ( is_final_stage_xcor() ) return
	}
}

void pool_tags() {

	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return

	if ( is_input_peak() ) return

	////////////// pool replicates and controls, then create ppr (pooled pseudoreplicates) before peak calling

	// make a temporary array of tagaligns, control tagaligns
	string[] tags, tags_pr1, tags_pr2, tags_ctl

	for ( int rep=1; rep<=get_num_rep(); rep++ ) {

		tags.add( tag{"rep$rep"} )

	 	if ( !true_rep ) {
			tags_pr1.add( tag_pr1{"rep$rep"} )
			tags_pr2.add( tag_pr2{"rep$rep"} )
		}

		if ( input_file_exists( 1, rep ) ) { // if control exists
			tags_ctl.add( tag{"ctl$rep"} )
		}
	}

	// if multiple tagalign for replicates, pool them
	if ( tags.size() > 1 ) {

	 	aln_pooled_o_dir := mkdir( "$out_dir/align/pooled_rep" )

		tag_pooled := pool_tag( tags, aln_pooled_o_dir, "pooled_rep" )

		add_file_to_report( tag_pooled, "tag-align", "pooled_rep", "Alignment/Pooled replicate/Tag-align" )

		tag{"pooled_rep"} = tag_pooled

	 	if ( !true_rep ) {

		 	aln_ppr1_o_dir   := mkdir( "$out_dir/align/pooled_pseudo_reps/ppr1" )
		 	aln_ppr2_o_dir   := mkdir( "$out_dir/align/pooled_pseudo_reps/ppr2" )

			qc_ppr1_o_dir    := mkdir( "$out_dir/qc/pooled_pseudo_reps/ppr1" ) // create qc output dir.
			qc_ppr2_o_dir    := mkdir( "$out_dir/qc/pooled_pseudo_reps/ppr2" ) // create qc output dir.

			tag_ppr1_ := pool_tag( tags_pr1, aln_ppr1_o_dir, "ppr1" )
			tag_ppr2_ := pool_tag( tags_pr2, aln_ppr2_o_dir, "ppr2" )
			tag_ppr1 = tag_ppr1_ // for thread safety
			tag_ppr2 = tag_ppr2_

			add_file_to_report( tag_ppr1_, "tag-align", "ppr1", \
						"Alignment/Pooled pseudo-replicates/Pooled pseudo-replicate 1/Tag-align" )
			add_file_to_report( tag_ppr2_, "tag-align", "ppr2", \
						"Alignment/Pooled pseudo-replicates/Pooled pseudo-replicate 2/Tag-align" )

			wait
		}
	}

	// if multiple tagalign for controls, pool them
	if ( tags_ctl.size() > 1 ) {

		aln_pooled_ctl_o_dir := mkdir( "$out_dir/align/pooled_ctl" )

		tag_pooled := pool_tag( tags_ctl, aln_pooled_ctl_o_dir, "pooled_ctl" )
		tag{"pooled_ctl"} = tag_pooled

		add_file_to_report( tag_pooled, "tag-align\\n(pooled ctl.)", "pooled_ctl", "Alignment/Pooled control/Tag-align" )
	}

	wait

	print( "\n== Done pool_tags()\n" )
}

void call_peaks() {

	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return

	if ( is_input_peak() ) return

	// make a temporary array of tagaligns, control tagaligns
	string[] tags, tags_pr1, tags_pr2, tags_ctl

	for ( int rep=1; rep<=get_num_rep(); rep++ ) {

		tags.add( tag{"rep$rep"} )

	 	if ( !true_rep ) {
			tags_pr1.add( tag_pr1{"rep$rep"} )
			tags_pr2.add( tag_pr2{"rep$rep"} )
		}

		if ( input_file_exists( 1, rep ) ) { // if control exists
			tags_ctl.add( tag{"ctl$rep"} )
		}
	}

	// choose control (between true and pooled controls) for each replicate
	string{} tag_ctl, tag_ctl_label // key: replicate id, value: actual control used for each replicate (according to control depth ratio)

	if ( tags_ctl.size() == 0 ) { // if no control at all

		tag_ctl{"pooled"} = ""

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			tag_ctl{rep} = ""
		}
	}
	else if ( tags_ctl.size() == 1 ) { // if only one control, use it for all replicates

		tag_ctl{"pooled"} = tags_ctl[0]

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			tag_ctl{rep} = tags_ctl[0]
		}
	}
	else { // if multiple controls, check # of lines in replicate/control tagaligns and apply ctl_depth_ratio

		tag_ctl{"pooled"} = tag{"pooled_ctl"}

		real{} nlines 		// # of lines in tagaligns, key: 0,rep for replicate, 1,rep for control
		real[] nlines_ctl 	// # of lines in control tagaligns

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			nlines{"rep$rep"} = get_num_lines( tag{"rep$rep"} )

			//print("DEBUG: # lines rep $rep tag.: " + nlines{"rep$rep"} + ", " + tag{"rep$rep"} + "\n")

			if ( input_file_exists( 1, rep ) ) { // if control exists

				nlines{"ctl$rep"} = get_num_lines( tag{"ctl$rep"} )
				nlines_ctl.add( nlines{"ctl$rep"} )

				//print("DEBUG: # lines ctl $rep tag.: " + nlines{"ctl$rep"} + ", " + tag{"ctl$rep"} + "\n")
			}
		}

		use_pooled_ctl_ := use_pooled_ctl

		for ( int i=0; i<nlines_ctl.size(); i++ ) { // check every # lines in every pair of control tagaligns
			for ( int j=i+1; j<nlines_ctl.size(); j++ ) {

				if ( 	nlines_ctl[i] / nlines_ctl[j] > ctl_depth_ratio || \
					nlines_ctl[j] / nlines_ctl[i] > ctl_depth_ratio ) {

					use_pooled_ctl_ = true

					print("\nNumber of reads in controls differ by a factor of $ctl_depth_ratio. Using pooled controls.\n" )

					break
				}
			}
		}

		for ( int rep=1; rep<=get_num_rep(); rep++ ) {

			if ( !use_pooled_ctl_ && input_file_exists( 1, rep ) ) {
			
				if ( nlines{"ctl$rep"} < nlines{"rep$rep"} ) {

					print("\nFewer reads in control $rep than experiment replicate $rep. Using pooled controls for replicate $rep.\n")

					tag_ctl{rep} = tag{"pooled_ctl"}
				}
				else {
					tag_ctl{rep} = tag{"ctl$rep"}
				}
			}
			else {
				tag_ctl{rep} = tag{"pooled_ctl"}
			}
		}
	}

	wait

	// get fragment length (required for SPP and MACS2)
	string fraglen_ppr1, fraglen_ppr2, fraglen_mean
	string{} fraglen_true, fraglen_pr1, fraglen_pr2 // key = replicate id

	real fraglen_sum = 0.0 // temp var.

	for (int rep=1; rep<=get_num_rep(); rep++) {

		if ( !no_xcor && xcor_qc.hasKey("rep$rep") ) fraglen_true{rep} = get_fraglen( xcor_qc{"rep$rep"} )
		else fraglen_true{rep} = 0

		if ( !true_rep ) {
			fraglen_pr1{rep} = fraglen_true{rep}
			fraglen_pr2{rep} = fraglen_true{rep}
		}

		fraglen_sum += fraglen_true{rep}.parseReal()
	}

	real num_rep_real = get_num_rep()

	fraglen_mean = round( fraglen_sum / num_rep_real ) // compute fraglen mean for pooled

	if ( !true_rep && get_num_rep() > 1 ) {
		fraglen_ppr1 = fraglen_mean
		fraglen_ppr2 = fraglen_mean
	}

	// distribute # of threads for each peak calling
	int nth_pooled, nth_other
	( nth_pooled, nth_other ) = distribute_nonzero( nth, [ get_num_rep(), 1, 1, 1 ] )

	// create directories for peaks (spp, macs2), signal tracks (macs2)
	string spp_o_dir, peakseq_o_dir, gem_o_dir
	if ( peak_caller == "spp" ) spp_o_dir = mkdir( "$out_dir/peak/spp")
	else if ( peak_caller == "peakseq" ) peakseq_o_dir = mkdir( "$out_dir/peak/peakseq")
	else if ( peak_caller == "gem" ) gem_o_dir = mkdir( "$out_dir/peak/gem")
	macs2_o_dir 	:= mkdir( "$out_dir/peak/macs2") 
	macs2_sig_o_dir	:= mkdir( "$out_dir/signal/macs2")

	string tmp

	// call peaks on pooled replicates and pooled pseudo replicates
	if ( get_num_rep() > 1 ) {

		// spp
		if ( peak_caller == "spp" ) {
			spp_pooled_o_dir := mkdir( "$spp_o_dir/pooled_rep" )
			( peak_pooled{"spp"}, tmp ) = \
				spp( tag{"pooled_rep"}, tag_ctl{"pooled"}, fraglen_mean, spp_pooled_o_dir, "pooled_rep", nth_pooled )
			add_file_to_report( peak_pooled{"spp"}, "r. peak", "pooled_rep", "Peaks/SPP/Pooled Replicate/Region peak" )
		}
		else if ( peak_caller == "peakseq" ) {
			peakseq_pooled_o_dir := mkdir( "$peakseq_o_dir/pooled_rep" )
			( peak_pooled{"peakseq"}, tmp ) = \
				peakseq( tag{"pooled_rep"}, tag_ctl{"pooled"}, fraglen_mean, peakseq_pooled_o_dir, "pooled_rep" )
			add_file_to_report( peak_pooled{"peakseq"}, "r. peak", "pooled_rep", "Peaks/PeakSeq/Pooled Replicate/Region peak" )
		}
		else if ( peak_caller == "gem" ) {
			gem_pooled_o_dir := mkdir( "$gem_o_dir/pooled_rep" )
			( peak_pooled{"gem"}, tmp ) = \
				gem( tag{"pooled_rep"}, tag_ctl{"pooled"}, gem_pooled_o_dir, "pooled_rep", nth_pooled )
			add_file_to_report( peak_pooled{"gem"}, "n. peak", "pooled_rep", "Peaks/Gem/Pooled Replicate/Region peak" )
		}

		// macs2
		macs2_pooled_o_dir     := mkdir( "$macs2_o_dir/pooled_rep" )
		macs2_pooled_sig_o_dir := mkdir( "$macs2_sig_o_dir/pooled_rep" )

		( peak_pooled{"macs2"}, fc_bigwig{"pooled"}, pval_bigwig{"pooled"} ) = \
				macs2_chipseq_npeak_and_signal( tag{"pooled_rep"}, tag_ctl{"pooled"}, fraglen_mean, \
				true, macs2_pooled_o_dir, macs2_pooled_sig_o_dir, "pooled_rep" )
		if ( peak_caller == "macs2" ) {
			if ( !disable_gb_peak ) {
				( gpeak_pooled{"macs2"}, bpeak_pooled{"macs2"} ) = \
					macs2_chipseq_gpeak_and_bpeak( tag{"pooled_rep"}, tag_ctl{"pooled"}, fraglen_mean, \
						macs2_pooled_o_dir, "pooled_rep" )
				add_file_to_report( gpeak_pooled{"macs2"}, "g. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Gapped peak" )
				add_file_to_report( bpeak_pooled{"macs2"}, "b. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Broad peak" )
			}
			add_file_to_report( peak_pooled{"macs2"}, "n. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Narrow peak" )
		}
		else if ( is_histone_chipseq() ) {
			add_file_to_report( peak_pooled{"macs2"}, "n. peak", "pooled_rep", "Peaks/MACS2/Pooled replicate/Narrow peak" )
		}
		else {
			add_file_to_table( peak_pooled{"macs2"}, "Peaks/MACS2/Pooled replicate/Narrow peak" )
		}
		add_file_to_report( fc_bigwig{"pooled"}, "signal fc", "pooled_rep", "Signal tracks/MACS2/Pooled replicate/Fold enrichment" )
		add_file_to_report( pval_bigwig{"pooled"}, "signal p-val", "pooled_rep", "Signal tracks/MACS2/Pooled replicate/P-value" )

		if ( !true_rep ) {
			// spp
			if ( peak_caller == "spp" ) {
				spp_ppr1_o_dir 	:= mkdir( "$spp_o_dir/pooled_pseudo_reps/ppr1" )
				spp_ppr2_o_dir 	:= mkdir( "$spp_o_dir/pooled_pseudo_reps/ppr2" )
				( peak_ppr1{"spp"}, tmp ) = \
					spp( tag_ppr1, tag_ctl{"pooled"}, fraglen_ppr1, spp_ppr1_o_dir, "ppr1", nth_other )
				( peak_ppr2{"spp"}, tmp ) = \
					spp( tag_ppr2, tag_ctl{"pooled"}, fraglen_ppr2, spp_ppr2_o_dir, "ppr2", nth_other )
				hrchy_ppr1 := "Peaks/SPP/Pooled pseudo-replicates/Pooled pseudo-replicate 1/Region peak"
				hrchy_ppr2 := "Peaks/SPP/Pooled pseudo-replicates/Pooled pseudo-replicate 2/Region peak"
				add_file_to_report( peak_ppr1{"spp"}, "r. peak", "ppr1", hrchy_ppr1 )
				add_file_to_report( peak_ppr2{"spp"}, "r. peak", "ppr2", hrchy_ppr2 )
			}
			else if ( peak_caller == "peakseq" ) {
				peakseq_ppr1_o_dir 	:= mkdir( "$peakseq_o_dir/pooled_pseudo_reps/ppr1" )
				peakseq_ppr2_o_dir 	:= mkdir( "$peakseq_o_dir/pooled_pseudo_reps/ppr2" )
				( peak_ppr1{"peakseq"}, tmp ) = \
					peakseq( tag_ppr1, tag_ctl{"pooled"}, fraglen_ppr1, peakseq_ppr1_o_dir, "ppr1" )
				( peak_ppr2{"peakseq"}, tmp ) = \
					peakseq( tag_ppr2, tag_ctl{"pooled"}, fraglen_ppr2, peakseq_ppr2_o_dir, "ppr2" )
				hrchy_ppr1 := "Peaks/PeakSeq/Pooled pseudo-replicates/Pooled pseudo-replicate 1/Region peak"
				hrchy_ppr2 := "Peaks/PeakSeq/Pooled pseudo-replicates/Pooled pseudo-replicate 2/Region peak"
				add_file_to_report( peak_ppr1{"peakseq"}, "r. peak", "ppr1", hrchy_ppr1 )
				add_file_to_report( peak_ppr2{"peakseq"}, "r. peak", "ppr2", hrchy_ppr2 )
			}
			else if ( peak_caller == "gem" ) {
				gem_ppr1_o_dir 	:= mkdir( "$gem_o_dir/pooled_pseudo_reps/ppr1" )
				gem_ppr2_o_dir 	:= mkdir( "$gem_o_dir/pooled_pseudo_reps/ppr2" )
				( peak_ppr1{"gem"}, tmp ) = \
					gem( tag_ppr1, tag_ctl{"pooled"}, gem_ppr1_o_dir, "ppr1", nth_other )
				( peak_ppr2{"gem"}, tmp ) = \
					gem( tag_ppr2, tag_ctl{"pooled"}, gem_ppr2_o_dir, "ppr2", nth_other )
				hrchy_ppr1 := "Peaks/Gem/Pooled pseudo-replicates/Pooled pseudo-replicate 1/Region peak"
				hrchy_ppr2 := "Peaks/Gem/Pooled pseudo-replicates/Pooled pseudo-replicate 2/Region peak"
				add_file_to_report( peak_ppr1{"gem"}, "n. peak", "ppr1", hrchy_ppr1 )
				add_file_to_report( peak_ppr2{"gem"}, "n. peak", "ppr2", hrchy_ppr2 )
			}

			// macs2
			if ( peak_caller == "macs2" || !sig_trk_for_pooled_rep_only ) {
				macs2_ppr1_o_dir:= mkdir( "$macs2_o_dir/pooled_pseudo_reps/ppr1" )
				macs2_ppr2_o_dir:= mkdir( "$macs2_o_dir/pooled_pseudo_reps/ppr2" )

				tmp1 := macs2_chipseq_npeak_and_signal( tag_ppr1, tag_ctl{"pooled"}, fraglen_ppr1, false, macs2_ppr1_o_dir, "", "ppr1" )
				peak_ppr1{"macs2"} = tmp1[0]
				tmp2 := macs2_chipseq_npeak_and_signal( tag_ppr2, tag_ctl{"pooled"}, fraglen_ppr2, false, macs2_ppr2_o_dir, "", "ppr2" )
				peak_ppr2{"macs2"} = tmp2[0]

				if ( peak_caller == "macs2" ) {
					if ( !disable_gb_peak ) {
						( gpeak_ppr1{"macs2"}, bpeak_ppr1{"macs2"} ) = \
							macs2_chipseq_gpeak_and_bpeak( tag_ppr1, tag_ctl{"pooled"}, fraglen_ppr1, macs2_ppr1_o_dir, "ppr1" )
						( gpeak_ppr2{"macs2"}, bpeak_ppr2{"macs2"} ) = \
							macs2_chipseq_gpeak_and_bpeak( tag_ppr2, tag_ctl{"pooled"}, fraglen_ppr2, macs2_ppr2_o_dir, "ppr2" )
						add_file_to_report( gpeak_ppr1{"macs2"}, "g. peak", "ppr1", \
							"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Gapped peak" )
						add_file_to_report( gpeak_ppr2{"macs2"}, "g. peak", "ppr2", \
							"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Gapped peak" )
						add_file_to_report( bpeak_ppr1{"macs2"}, "b. peak", "ppr1", \
							"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Broad peak" )
						add_file_to_report( bpeak_ppr2{"macs2"}, "b. peak", "ppr2", \
							"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Broad peak" )
					}
					add_file_to_report( peak_ppr1{"macs2"}, "n. peak", "ppr1", \
						"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Narrow peak" )
					add_file_to_report( peak_ppr2{"macs2"}, "n. peak", "ppr2", \
						"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Narrow peak" )
				}
				else if ( is_histone_chipseq() ) {
					add_file_to_report( peak_ppr1{"macs2"}, "n. peak", "ppr1", \
						"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Narrow peak" )
					add_file_to_report( peak_ppr2{"macs2"}, "n. peak", "ppr2", \
						"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Narrow peak" )
				}
				else {
					add_file_to_table( peak_ppr1{"macs2"}, \
						"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 1/Narrow peak" )
					add_file_to_table( peak_ppr2{"macs2"}, \
						"Peaks/MACS2/Pooled pseudo-replicate/Pooled pseudo-replicate 2/Narrow peak" )
				}
			}
		}
	}

	// call peaks for each replicate and pseudo replicates for it
	for (int rep=1; rep<=get_num_rep(); rep++) {

		// spp
		if ( peak_caller == "spp" ) {
			spp_true_o_dir := mkdir( "$spp_o_dir/rep$rep" )
			( peak{"spp,$rep"}, tmp ) = \
				spp( tag{"rep$rep"}, tag_ctl{rep}, fraglen_true{rep}, spp_true_o_dir, "rep$rep", nth_other )
			add_file_to_report( peak{"spp,$rep"}, "r. peak", "rep$rep", "Peaks/SPP/Replicate $rep/Region peak" )
		}
		else if ( peak_caller == "peakseq" ) {
			peakseq_true_o_dir := mkdir( "$peakseq_o_dir/rep$rep" )
			( peak{"peakseq,$rep"}, tmp ) = \
				peakseq( tag{"rep$rep"}, tag_ctl{rep}, fraglen_true{rep}, peakseq_true_o_dir, "rep$rep" )
			add_file_to_report( peak{"peakseq,$rep"}, "r. peak", "rep$rep", "Peaks/PeakSeq/Replicate $rep/Region peak" )
		}
		else if ( peak_caller == "gem" ) {
			gem_true_o_dir	:= mkdir( "$gem_o_dir/rep$rep" )
			( peak{"gem,$rep"}, tmp ) = \
				gem( tag{"rep$rep"}, tag_ctl{rep}, gem_true_o_dir, "rep$rep", nth_other )
			add_file_to_report( peak{"gem,$rep"}, "n. peak", "rep$rep", "Peaks/Gem/Replicate $rep/Region peak" )
		}

		// macs2
		if ( peak_caller == "macs2" || !sig_trk_for_pooled_rep_only ) {

			macs2_true_o_dir	:= mkdir( "$macs2_o_dir/rep$rep" )
			macs2_true_sig_dir 	:= mkdir( "$macs2_sig_o_dir/rep$rep" )

			( peak{"macs2,$rep"}, fc_bigwig{rep}, pval_bigwig{rep} ) = \
				macs2_chipseq_npeak_and_signal( tag{"rep$rep"}, tag_ctl{rep}, fraglen_true{rep}, true, macs2_true_o_dir, macs2_true_sig_dir, "rep$rep" )

			if ( peak_caller == "macs2" ) {
				if ( !disable_gb_peak ) {
					( gpeak{"macs2,$rep"}, bpeak{"macs2,$rep"} ) = \
						macs2_chipseq_gpeak_and_bpeak( tag{"rep$rep"}, tag_ctl{rep}, fraglen_true{rep}, macs2_true_o_dir, "rep$rep" )
					add_file_to_report( gpeak{"macs2,$rep"}, "g. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Gapped peak" )
					add_file_to_report( bpeak{"macs2,$rep"}, "b. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Broad peak" )
				}
				add_file_to_report( peak{"macs2,$rep"}, "n. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Narrow peak" )
			}
			else if ( is_histone_chipseq() ) {
				add_file_to_report( peak{"macs2,$rep"}, "n. peak", "rep$rep", "Peaks/MACS2/Replicate $rep/Narrow peak" )
			}
			else {
				add_file_to_table( peak{"macs2,$rep"}, "Peaks/MACS2/Replicate $rep/Narrow peak" )
			}
			add_file_to_report( fc_bigwig{rep}, "signal fc", "rep$rep", "Signal tracks/MACS2/Replicate $rep/Fold enrichment" )
			add_file_to_report( pval_bigwig{rep}, "signal p-val", "rep$rep", "Signal tracks/MACS2/Replicate $rep/P-value" )
		}

		if ( !true_rep ) {

			if ( !no_pseudo_rep ) {

				if ( peak_caller == "spp" ) {
					spp_pr1_o_dir 	:= mkdir( "$spp_o_dir/pseudo_reps/rep$rep/pr1" )
					spp_pr2_o_dir 	:= mkdir( "$spp_o_dir/pseudo_reps/rep$rep/pr2" )
					( peak_pr1{"spp,$rep"}, tmp ) = \
						spp( tag_pr1{"rep$rep"}, tag_ctl{rep}, fraglen_pr1{rep}, spp_pr1_o_dir, \
										"rep$rep-pr1", nth_other )
					( peak_pr2{"spp,$rep"}, tmp ) = \
						spp( tag_pr2{"rep$rep"}, tag_ctl{rep}, fraglen_pr2{rep}, spp_pr2_o_dir, \
										"rep$rep-pr2", nth_other )
					add_file_to_report( peak_pr1{"spp,$rep"}, "r. peak", "rep$rep-pr1", \
								"Peaks/SPP/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Region peak" )
					add_file_to_report( peak_pr2{"spp,$rep"}, "r. peak", "rep$rep-pr2", \
								"Peaks/SPP/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Region peak" )
				}
				else if ( peak_caller == "peakseq" ) {
					peakseq_pr1_o_dir 	:= mkdir( "$peakseq_o_dir/pseudo_reps/rep$rep/pr1" )
					peakseq_pr2_o_dir 	:= mkdir( "$peakseq_o_dir/pseudo_reps/rep$rep/pr2" )
					( peak_pr1{"peakseq,$rep"}, tmp ) = \
						peakseq( tag_pr1{"rep$rep"}, tag_ctl{rep}, fraglen_pr1{rep}, peakseq_pr1_o_dir, \
										"rep$rep-pr1" )
					( peak_pr2{"peakseq,$rep"}, tmp ) = \
						peakseq( tag_pr2{"rep$rep"}, tag_ctl{rep}, fraglen_pr2{rep}, peakseq_pr2_o_dir, \
										"rep$rep-pr2" )
					add_file_to_report( peak_pr1{"peakseq,$rep"}, "r. peak", "rep$rep-pr1", \
								"Peaks/peakseq/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Region peak" )
					add_file_to_report( peak_pr2{"peakseq,$rep"}, "r. peak", "rep$rep-pr2", \
								"Peaks/peakseq/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Region peak" )
				}
				else if ( peak_caller == "gem" ) {
					gem_pr1_o_dir 	:= mkdir( "$gem_o_dir/pseudo_reps/rep$rep/pr1" )
					gem_pr2_o_dir 	:= mkdir( "$gem_o_dir/pseudo_reps/rep$rep/pr2" )
					( peak_pr1{"gem,$rep"}, tmp ) = \
						gem( tag_pr1{"rep$rep"}, tag_ctl{rep}, gem_pr1_o_dir, \
										"rep$rep-pr1", nth_other )
					( peak_pr2{"gem,$rep"}, tmp ) = \
						gem( tag_pr2{"rep$rep"}, tag_ctl{rep}, gem_pr2_o_dir, \
										"rep$rep-pr2", nth_other )
					add_file_to_report( peak_pr1{"gem,$rep"}, "n. peak", "rep$rep-pr1", \
								"Peaks/gem/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Region peak" )
					add_file_to_report( peak_pr2{"gem,$rep"}, "n. peak", "rep$rep-pr2", \
								"Peaks/gem/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Region peak" )
				}

				if ( peak_caller == "macs2" || !sig_trk_for_pooled_rep_only ) {

					macs2_pr1_o_dir := mkdir( "$macs2_o_dir/pseudo_reps/rep$rep/pr1" )
					macs2_pr2_o_dir := mkdir( "$macs2_o_dir/pseudo_reps/rep$rep/pr2" )

					tmp1 := macs2_chipseq_npeak_and_signal( tag_pr1{"rep$rep"}, tag_ctl{rep}, fraglen_pr1{rep}, false, macs2_pr1_o_dir, "", "rep$rep-pr1" )
					peak_pr1{"macs2,$rep"} = tmp1[0]
					tmp2 := macs2_chipseq_npeak_and_signal( tag_pr2{"rep$rep"}, tag_ctl{rep}, fraglen_pr2{rep}, false, macs2_pr2_o_dir, "", "rep$rep-pr2" )
					peak_pr2{"macs2,$rep"} = tmp2[0]
					if ( peak_caller == "macs2" ) {
						if ( !disable_gb_peak ) {
							( gpeak_pr1{"macs2,$rep"}, bpeak_pr1{"macs2,$rep"} ) = \
								macs2_chipseq_gpeak_and_bpeak( tag_pr1{"rep$rep"}, tag_ctl{rep}, fraglen_pr1{rep}, macs2_pr1_o_dir, "rep$rep-pr1" )
							( gpeak_pr2{"macs2,$rep"}, bpeak_pr2{"macs2,$rep"} ) = \
								macs2_chipseq_gpeak_and_bpeak( tag_pr2{"rep$rep"}, tag_ctl{rep}, fraglen_pr2{rep}, macs2_pr2_o_dir, "rep$rep-pr2" )
							add_file_to_report( gpeak_pr1{"macs2,$rep"}, "g. peak", "rep$rep-pr1", \
								"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Gapped peak" )
							add_file_to_report( gpeak_pr2{"macs2,$rep"}, "g. peak", "rep$rep-pr2", \
								"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Gapped peak" )
							add_file_to_report( bpeak_pr1{"macs2,$rep"}, "b. peak", "rep$rep-pr1", \
								"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Broad peak" )
							add_file_to_report( bpeak_pr2{"macs2,$rep"}, "b. peak", "rep$rep-pr2", \
								"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Broad peak" )
						}
						add_file_to_report( peak_pr1{"macs2,$rep"}, "n. peak", "rep$rep-pr1", \
							"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Narrow peak" )
						add_file_to_report( peak_pr2{"macs2,$rep"}, "n. peak", "rep$rep-pr2", \
							"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Narrow peak" )
					}
					else if ( is_histone_chipseq() ) {
						add_file_to_report( peak_pr1{"macs2,$rep"}, "n. peak", "rep$rep-pr1", \
							"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Narrow peak" )
						add_file_to_report( peak_pr2{"macs2,$rep"}, "n. peak", "rep$rep-pr2", \
							"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Narrow peak" )
					}
					else {
						add_file_to_table( peak_pr1{"macs2,$rep"}, \
							"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 1/Narrow peak" )
						add_file_to_table( peak_pr2{"macs2,$rep"}, \
							"Peaks/MACS2/Pseudo-replicates/Replicate $rep/Pseudo-replicate 2/Narrow peak" )
					}
				}
			}
		}
	}

	wait

	print( "\n== Done call_peaks()\n" )
}

void read_input_peak() {

	if ( !is_input_peak() ) return // read peaks here

	for ( int rep=0; rep<=get_num_rep_peak(); rep++) { // rep==0 : pooled
		if ( get_num_rep_peak() == 1 && rep==0 ) continue // if only one replicate, skip reading pooled rep

		for (int pse=0; pse<=2; pse++) { // pse==0 : true rep
			if ( true_rep && pse > 0 ) continue
			if ( no_pseudo_rep && rep != 0 && pse > 0 ) continue

			peak_ := get_peak(rep,pse)
			if ( rep == 0 ) {
				if ( pse == 0 )		peak_pooled{"$peak_caller"} 	= peak_
				else if ( pse == 1 )	peak_ppr1{"$peak_caller"} 	= peak_
				else if ( pse == 2 )	peak_ppr2{"$peak_caller"} 	= peak_
			}
			else {
				if ( pse == 0 )		peak{"$peak_caller,$rep"} 	= peak_
				else if ( pse == 1 )	peak_pr1{"$peak_caller,$rep"} 	= peak_
				else if ( pse == 2 )	peak_pr2{"$peak_caller,$rep"} 	= peak_
			}
		}
	}
}

void naive_overlap() {
	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return
	if ( !peak_exists() ) return // if no peaks from peak caller exit

	// peak caller
	peak_o_dir := "$out_dir/peak/$peak_caller"
	peak_overlap_o_dir_old_version := "$peak_o_dir/../overlap"
	peak_overlap_o_dir := "$peak_o_dir/overlap"
	// for backward compatibility (old version has idr on out/peak), make symlink for old dir. to new dir. 
	if ( path_exists( peak_overlap_o_dir_old_version ) ) { 
		system := "local"
		task {
			sys cd $peak_o_dir
			sys rm -f overlap
			sys ln -s ../overlap
		}
	}
	else {
		peak_overlap_o_dir = mkdir( peak_overlap_o_dir )
	}
	wait

	string filetype
	if ( peak_caller == "macs2" || peak_caller == "gem" ) {
		filetype = "narrowPeak"
	}
	else if ( peak_caller == "spp" || peak_caller == "peakseq" ) {
		filetype = "regionPeak"
	}
	else error("Naive overlap not supported for peak_caller=$peak_caller")

	// naive overlap on true replicates (on every pair of peaks from replicates)
	for ( int i=1; i<=get_num_rep(); i++ ) {
		for ( int j=i+1; j<=get_num_rep(); j++ ) {

			peak_overlap_true_o_dir := mkdir( "$peak_overlap_o_dir/true_reps/rep$i-rep$j" )
			peak_overlap_tr{"$i,$j"} = \
				naive_overlap_peak( filetype, peak{"$peak_caller,$i"}, peak{"$peak_caller,$j"}, peak_pooled{"$peak_caller"}, peak_overlap_true_o_dir, "rep$i-rep$j" )
			add_file_to_report( peak_overlap_tr{"$i,$j"}, "Overlap peak", "rep$i-rep$j", "Peaks/"+peak_caller.toUpper()+\
				"/Naive overlap/True replicates/Rep. $i vs. Rep. $j/Overlapping peak" )
		}

		if ( !true_rep && !no_pseudo_rep ) {
			peak_overlap_pr_o_dir := mkdir( "$peak_overlap_o_dir/pseudo_reps/rep$i" )
			peak_overlap_pr{i} = \
				naive_overlap_peak( filetype, peak_pr1{"$peak_caller,$i"}, peak_pr2{"$peak_caller,$i"}, peak{"$peak_caller,$i"}, peak_overlap_pr_o_dir, "rep$i-pr" )
			add_file_to_report( peak_overlap_pr{i}, "Overlap peak", "rep$i-pr", "Peaks/"+peak_caller.toUpper()+\
				"/Naive overlap/Pseudo-replicates/Replicate $i/Overlapping peak" )
		}
	}

	if ( !true_rep && get_num_rep() > 1 ) {
		peak_overlap_ppr_o_dir := mkdir( "$peak_overlap_o_dir/pooled_pseudo_reps" )
		peak_overlap_ppr = \
			naive_overlap_peak( filetype, peak_ppr1{"$peak_caller"}, peak_ppr2{"$peak_caller"}, peak_pooled{"$peak_caller"}, peak_overlap_ppr_o_dir, "ppr" )
		add_file_to_report( peak_overlap_ppr, "Overlap peak", "ppr", "Peaks/"+peak_caller.toUpper()+"/Naive overlap/Pooled pseudo-replicates/Overlapping peak" )
	}

	wait

	qc_o_dir := mkdir( "$out_dir/qc" ) // create qc output dir.

	// get final idr qc score, use idr final idr narrow peak files from true, pseudo and pooled pseudo reps
	(peak_overlap_qc, peak_overlap_opt, peak_overlap_consv) = peak_overlap_final_qc( peak_overlap_tr, peak_overlap_pr, peak_overlap_ppr, peak_overlap_o_dir, qc_o_dir, "" )

	add_file_to_report( peak_overlap_qc, "Naive overlap QC log", "", "QC and logs/Naive overlap/Overlap QC log" )
	add_file_to_report( peak_overlap_opt, "opt. overlap peak", "", "Peaks/"+peak_caller.toUpper()+"/Naive overlap/Optimal set/Overlapping peak" )
	add_file_to_report( peak_overlap_consv, "consv. overlap peak", "", "Peaks/"+peak_caller.toUpper()+"/Naive overlap/Conservative set/Overlapping peak" )

	// FRiP (fraction of reads in peak)
	if ( !is_input_peak() && xcor_qc ) {
		string{} fraglen_true
		real fraglen_sum = 0.0 // temp var.
		for ( int rep=1; rep<=get_num_rep(); rep++ ) {
			group := get_group_name( 0, rep ) // for each experiment replicate
			fraglen_true{rep} = get_fraglen( xcor_qc{group} )
			if ( peak_overlap_pr.hasKey(rep) ) {
				peak_overlap_pr_o_dir := mkdir( "$peak_overlap_o_dir/pseudo_reps/rep$rep" )
				peak_overlap_qc_FRiP{"rep$rep-pr"} = \
					FRiP_shifted( tag{group}, peak_overlap_pr{rep}, parse_int(fraglen_true{rep}), peak_overlap_pr_o_dir, "rep$rep-pr" )
				add_file_to_table( peak_overlap_qc_FRiP{"rep$rep-pr"}, "QC and logs/Naive overlap/Pseudo-replicates/Replicate $rep/FRiP" )
			}
			fraglen_sum += fraglen_true{rep}.parseReal()
		}
		real num_rep_real = get_num_rep()
		fraglen_mean := round( fraglen_sum / num_rep_real ) // compute fraglen mean for pooled
		if ( get_num_rep()>1 && peak_overlap_qc_FRiP.hasKey("ppr") ) {
			peak_overlap_ppr_o_dir := mkdir( "$peak_overlap_o_dir/pooled_pseudo_reps" )
			peak_overlap_qc_FRiP{"ppr"} = \
				FRiP_shifted( tag{"pooled_rep"}, peak_overlap_ppr, parse_int(fraglen_mean), peak_overlap_ppr_o_dir, "ppr" )
			add_file_to_table( peak_overlap_qc_FRiP{"ppr"}, "QC and logs/Naive overlap/Pooled pseudo-replicates/FRiP" )
		}
		for ( int i=1; i<=get_num_rep(); i++ ) {
			for ( int j=i+1; j<=get_num_rep(); j++ ) {				
				peak_overlap_true_o_dir := mkdir( "$peak_overlap_o_dir/true_reps/rep$i-rep$j" )
				peak_overlap_qc_FRiP{"rep$i-rep$j"} = \
					FRiP_shifted( tag{"pooled_rep"}, peak_overlap_tr{"$i,$j"}, parse_int(fraglen_mean), \
						peak_overlap_true_o_dir, "rep$i-rep$j" )
				add_file_to_table( peak_overlap_qc_FRiP{"rep$i-rep$j"}, \
					"QC and logs/Naive overlap/True replicates/Rep. $i vs. Rep. $j/FRiP" )
			}
		}
	}
	wait

	print( "\n== Done naive_overlap()\n" )
}

void do_idr() {

	if ( !is_final_stage_idr() ) return
	if ( is_histone_chipseq() ) return
	if ( !peak_exists() ) return // if no peaks from peak caller exit

	// peak caller
	peak_o_dir := "$out_dir/peak/$peak_caller"
	idr_o_dir_old_version := "$peak_o_dir/../idr"
	idr_o_dir := "$peak_o_dir/idr"
	// for backward compatibility (old version has idr on out/peak), make symlink for old dir. to new dir. 
	if ( path_exists( idr_o_dir_old_version ) ) { 
		system := "local"
		task {
			sys cd $peak_o_dir
			sys rm -f idr
			sys ln -s ../idr
		}
	}
	else {
		idr_o_dir = mkdir( idr_o_dir )
	}
	wait

	// IDR on true replicates (on every pair of peaks from replicates)
	for ( int i=1; i<=get_num_rep(); i++ ) {

		for ( int j=i+1; j<=get_num_rep(); j++ ) {

			idr_true_o_dir 	:= mkdir( "$idr_o_dir/true_reps/rep$i-rep$j" )

			(idr_tr{"$i,$j"}, idr_tr_png{"$i,$j"} ) = \
				idr2( peak{"$peak_caller,$i"}, peak{"$peak_caller,$j"}, peak_pooled{"$peak_caller"}, idr_thresh, idr_rank, idr_true_o_dir, "rep$i-rep$j" )

			add_file_to_report( idr_tr{"$i,$j"}, "IDR peak", "rep$i-rep$j", "Peaks/"+peak_caller.toUpper()+\
				"/IDR/True replicates/Rep. $i vs. Rep. $j/IDR peak" )
			add_file_to_table( idr_tr_png{"$i,$j"}, "QC and logs/IDR/True replicates/Rep. $i vs. Rep. $j/IDR plot" )			
		}

		if ( !true_rep && !no_pseudo_rep ) {

			idr_pr_o_dir := mkdir( "$idr_o_dir/pseudo_reps/rep$i" )

			(idr_pr{i}, idr_pr_png{i}) = \
				idr2( peak_pr1{"$peak_caller,$i"}, peak_pr2{"$peak_caller,$i"}, peak{"$peak_caller,$i"}, idr_thresh, idr_rank, idr_pr_o_dir, "rep$i-pr" )

			add_file_to_report( idr_pr{i}, "IDR peak", "rep$i-pr", "Peaks/"+peak_caller.toUpper()+\
				"/IDR/Pseudo-replicates/Replicate $i/IDR peak" )
			add_file_to_table( idr_pr_png{i}, "QC and logs/IDR/Pseudo-replicates/Replicate $i/IDR plot" )
		}
	}

	if ( !true_rep && get_num_rep() > 1 ) {

		idr_ppr_o_dir := mkdir( "$idr_o_dir/pooled_pseudo_reps" )

		(idr_ppr, idr_ppr_png) = \
			idr2( peak_ppr1{"$peak_caller"}, peak_ppr2{"$peak_caller"}, peak_pooled{"$peak_caller"}, idr_thresh, idr_rank, idr_ppr_o_dir, "ppr" )

		add_file_to_report( idr_ppr, "IDR peak", "ppr", "Peaks/"+peak_caller.toUpper()+"/IDR/Pooled pseudo-replicates/IDR peak" )
		add_file_to_table( idr_ppr_png, "QC and logs/IDR/Pooled pseudo-replicates/IDR plot" )
	}

	wait

	qc_o_dir := mkdir( "$out_dir/qc" ) // create qc output dir.

	// get final idr qc score, use idr final idr narrow peak files from true, pseudo and pooled pseudo reps
	(idr_qc, idr_opt, idr_consv) = idr_final_qc( idr_tr, idr_pr, idr_ppr, idr_o_dir, qc_o_dir, "" )

	add_file_to_report( idr_qc, "IDR QC log", "", "QC and logs/IDR/IDR QC log" )
	add_file_to_report( idr_opt, "opt. IDR peak", "", "Peaks/"+peak_caller.toUpper()+"/IDR/Optimal set/IDR peak" )
	add_file_to_report( idr_consv, "consv. IDR peak", "", "Peaks/"+peak_caller.toUpper()+"/IDR/Conservative set/IDR peak" )

	// FRiP (fraction of reads in peak)
	if ( !is_input_peak() && xcor_qc ) {
		string{} fraglen_true
		real fraglen_sum = 0.0 // temp var.
		for ( int rep=1; rep<=get_num_rep(); rep++ ) {
			group := get_group_name( 0, rep ) // for each experiment replicate
			fraglen_true{rep} = get_fraglen( xcor_qc{group} )
			if ( idr_pr.hasKey(rep) ) {
				idr_pr_o_dir := mkdir( "$idr_o_dir/pseudo_reps/rep$rep" )
				idr_qc_FRiP{"rep$rep-pr"} = \
					FRiP_shifted( tag{group}, idr_pr{rep}, parse_int(fraglen_true{rep}), idr_pr_o_dir, "rep$rep-pr" )
				add_file_to_table( idr_qc_FRiP{"rep$rep-pr"}, "QC and logs/IDR/Pseudo-replicates/Replicate $rep/FRiP" )
			}
			fraglen_sum += fraglen_true{rep}.parseReal()
		}
		real num_rep_real = get_num_rep()
		fraglen_mean := round( fraglen_sum / num_rep_real ) // compute fraglen mean for pooled
		if ( get_num_rep()>1 && idr_qc_FRiP.hasKey("ppr") ) {
			idr_ppr_o_dir := mkdir( "$idr_o_dir/pooled_pseudo_reps" )
			idr_qc_FRiP{"ppr"} = \
				FRiP_shifted( tag{"pooled_rep"}, idr_ppr, parse_int(fraglen_mean), idr_ppr_o_dir, "ppr" )
			add_file_to_table( idr_qc_FRiP{"ppr"}, "QC and logs/IDR/Pooled pseudo-replicates/FRiP" )
		}
		for ( int i=1; i<=get_num_rep(); i++ ) {
			for ( int j=i+1; j<=get_num_rep(); j++ ) {				
				idr_true_o_dir 	:= mkdir( "$idr_o_dir/true_reps/rep$i-rep$j" )
				idr_qc_FRiP{"rep$i-rep$j"} = \
					FRiP_shifted( tag{"pooled_rep"}, idr_tr{"$i,$j"}, parse_int(fraglen_mean), \
						idr_true_o_dir, "rep$i-rep$j" )
				add_file_to_table( idr_qc_FRiP{"rep$i-rep$j"}, \
					"QC and logs/IDR/True replicates/Rep. $i vs. Rep. $j/FRiP" )
			}
		}
	}
	wait

	print( "\n== Done do_idr()\n" )	
}

void log_number_of_peaks() {
	if ( !(is_final_stage_peak() || is_final_stage_idr()) ) return
	if ( !peak_exists() ) return // if no peaks from peak caller exit

	log_o_dir := mkdir("$out_dir/qc")
	num_peak_log = "$log_o_dir/number_of_peaks.txt"
	string lines
	for ( int rep=1; rep<=get_num_rep(); rep++) { // rep==0 : pooled
		if ( peak.hasKey("$peak_caller,$rep") ) \
			lines += "rep$rep\t"+get_num_lines( peak{"$peak_caller,$rep"} )+"\n"
		if ( peak_pr1.hasKey("$peak_caller,$rep") ) \
			lines += "rep$rep-pr1\t"+get_num_lines( peak_pr1{"$peak_caller,$rep"} )+"\n"
		if ( peak_pr2.hasKey("$peak_caller,$rep") ) \
			lines += "rep$rep-pr2\t"+get_num_lines( peak_pr2{"$peak_caller,$rep"} )+"\n"
	}
	if ( peak_pooled.hasKey("$peak_caller") ) \
		lines += "pooled\t"+get_num_lines( peak_pooled{"$peak_caller"} )+"\n"
	if ( peak_ppr1.hasKey("$peak_caller") ) \
		lines += "ppr1\t"+get_num_lines( peak_ppr1{"$peak_caller"} )+"\n"
	if ( peak_ppr2.hasKey("$peak_caller") ) \
		lines += "ppr2\t"+get_num_lines( peak_ppr2{"$peak_caller"} )+"\n"
	// if ( peak_overlap ) \
	// 	lines += "overlap\t"+get_num_lines( peak_overlap )+"\n"
	// if ( gpeak_overlap ) \
	// 	lines += "overlap (gpeak)\t"+get_num_lines( gpeak_overlap )+"\n"
	num_peak_log.write(lines)
}

// black list filter and then calculate FRIP on filtered peakfile
void filter_peak() {
	if ( is_final_stage_before_peak() ) return
	if ( !path_exists( blacklist ) ) return

	string file_type
	// peaks for true replicates
	if ( peak_caller == "macs2" || peak_caller == "gem" ) {
		file_type = "narrowPeak"
	}
	else if ( peak_caller == "spp" || peak_caller == "peakseq" ) {
		file_type = "regionPeak"
	}
	string{} fraglen_true
	real fraglen_sum = 0.0 // temp var.	
	for (int rep=1; rep<=get_num_rep(); rep++) {
		// blacklist filter
		if ( !peak.hasKey(peak_caller+",$rep") ) continue
		filt_peak := \
			blacklist_filter_peak( file_type, peak{peak_caller+",$rep"}, (peak{peak_caller+",$rep"}).dirName(), "peak $rep" )
		// FRiP
		if ( xcor_qc ) {
			group := get_group_name( 0, rep ) // for each experiment replicate
			fraglen_true{rep} = get_fraglen( xcor_qc{group} )
			fraglen_sum += fraglen_true{rep}.parseReal()
			raw_peak_o_dir := mkdir( "$out_dir/peak/$peak_caller/rep$rep" )
			raw_peak_qc_FRiP{"rep$rep"} = \
				FRiP_shifted( tag{group}, filt_peak, parse_int(fraglen_true{rep}), raw_peak_o_dir, "rep$rep" )
			// add_file_to_table( raw_peak_qc_FRiP{"rep$rep"}, "QC and logs/"+peak_caller.toUpper()+"/True replicates/Replicate $rep/FRiP" )
		}
	}
	if ( get_num_rep() > 1 && peak_pooled.hasKey(peak_caller) ) {
		// blacklist filter
		filt_peak_pooled := \
			blacklist_filter_peak( file_type, peak_pooled{peak_caller}, (peak_pooled{peak_caller}).dirName(), "peak_pooled" )
		// FRiP
		if ( xcor_qc ) {
			real num_rep_real = get_num_rep()
			fraglen_mean := round( fraglen_sum / num_rep_real ) // compute fraglen mean for pooled

			raw_peak_o_dir := mkdir( "$out_dir/peak/$peak_caller/pooled_rep" )
			raw_peak_qc_FRiP{"pooled_rep"} = \
				FRiP_shifted( tag{"pooled_rep"}, filt_peak_pooled, parse_int(fraglen_mean), raw_peak_o_dir, "pooled_rep" )
			// add_file_to_table( raw_peak_qc_FRiP{"pooled_rep"}, "QC and logs/"+peak_caller.toUpper()+"/Pooled replicate/FRiP" )
		}
	}
	wait

	print( "\n== Done filter_peak()\n" )	
}

void report() {

	wait

	string html
	html += html_title()
	html += html_cmd_line_args()
	html += html_conf_file_info()
	html += html_pipeline_version( "https://github.com/kundajelab/TF_chipseq_pipeline/commit" ) // pipeline version info
	html += html_filetable() 	// treeview for directory and file structure 
	html += html_chipseq_tracks() 	// epigenome browser tracks
	html += html_graph()		// graphviz workflow diagram
	html += html_chipseq_QC()	// show QC tables and images

	report( html )
	write_summary_json()

	print( "\n== Done report()\n" )		
}

string html_chipseq_QC() {

	string[] flagstat_qcs, dup_qcs, flagstat_nodup_qcs, pbc_qcs, xcor_qcs, xcor_plots, jsd_qcs
	string[] groups, groups_no_ctl

	for ( int rep=1; rep <= get_num_rep(); rep++) {
		group := "rep$rep"
		groups.add( group )
		groups_no_ctl.add( group )

		if ( xcor_qc.hasKey( group ) )	{
			xcor_qcs 		+= xcor_qc{group}
			xcor_plots 		+= xcor_plot{group}
		}
		if ( flagstat_qc.hasKey( group ) )	flagstat_qcs 		+= flagstat_qc{group}
		if ( dup_qc.hasKey( group ) ) 		dup_qcs 		+= dup_qc{group}
		if ( flagstat_nodup_qc.hasKey( group ) )	flagstat_nodup_qcs 	+= flagstat_nodup_qc{group}
		if ( pbc_qc.hasKey( group ) ) 		pbc_qcs			+= pbc_qc{group}
		if ( jsd_qc.hasKey( group ) ) 		jsd_qcs			+= jsd_qc{group}
	}
	for ( int rep=1; rep<=get_num_rep(); rep++ ) {
		if ( input_file_exists( 1, rep ) ) { // if control exists
			group := "ctl$rep"
			groups.add( group )
			if ( flagstat_qc.hasKey( group ) )	flagstat_qcs 		+= flagstat_qc{group}
			if ( dup_qc.hasKey( group ) ) 		dup_qcs 		+= dup_qc{group}
			if ( flagstat_nodup_qc.hasKey( group ) )	flagstat_nodup_qcs 	+= flagstat_nodup_qc{group}
			if ( pbc_qc.hasKey( group ) ) 		pbc_qcs			+= pbc_qc{group}
		}
	}

	html := "<div id='chipseq_qc'>"
	html += "<div style='float:left'>"

	html += html_table_multiple_logs( "Flagstat (raw) QC", false, "flagstat", groups, flagstat_qcs )
	html += "</div>"
	if ( !no_dup_removal ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Flagstat (filtered) QC", false, "flagstat_filt", groups, flagstat_nodup_qcs )
		html += "</div>"
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Dup. QC", false, "dup", groups, dup_qcs )
		html += "</div>"
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Fingerprint JS metric", false, "jsd", groups, jsd_qcs )
		if ( jsd_png ) {
			html += html_img( jsd_png, 800, "Fingerprint plot" ) + "<br>"
		}
		html += "</div>"
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Library Complexity QC", false, has_pe() ? "pbc_PE" : "pbc", groups, pbc_qcs )
		if ( pbc_qcs.size()>0 ) html += html_help_pbc()
		html += "</div>"
	}
	html += "<div style='float:left'>"
	html += html_table_multiple_logs( "Enrichment QC (strand cross-correlation measures)", false, "xcor", groups, xcor_qcs )
	if ( xcor_qcs.size()>0 ) html += html_help_xcor( subsample_xcor, has_se(), has_pe() )
	html += "</div>"
	// xcor images
	for ( int i=0; i<xcor_plots.size(); i++ ) {
		png := pdf_to_png( xcor_plots[i] )
		html += html_img( png, 500, groups[i] ) + "&nbsp"
	}
	// number of peaks
	if ( num_peak_log ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Number of peaks", false, "num_peaks", num_peak_log )
		html += html_help_num_peaks()
		html += "</div>"
	}
	// FRiP (raw peaks; macs2 or spp)
	if ( raw_peak_qc_FRiP.size()>0 ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Enrichment QC (Fraction of reads in raw peaks)", false, "FRiP", raw_peak_qc_FRiP )
		html += "</div>"
	}
	// FRiP (Naive overlap)
	if ( peak_overlap_qc_FRiP.size()>0 ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Enrichment QC (Fraction of reads in overlapping peaks)", false, "overlap_FRiP", peak_overlap_qc_FRiP )
		html += html_help_peak_overlap_FRiP()
		html += "</div>"
	}
	if ( peak_overlap_qc != "" ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Reproducibility QC and Peak Detection Statistics (Overlapping peaks)", \
							false, "overlap", ["rep1"], [peak_overlap_qc] )
		html += html_help_peak_overlap()
		html += "</div>"
	}
	// FRiP (IDR)
	if ( idr_qc_FRiP.size()>0 ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Enrichment QC (Fraction of reads in IDR peaks)", false, "idr_FRiP", idr_qc_FRiP )
		html += html_help_idr_FRiP()
		html += "</div>"
	}
	if ( idr_qc != "" ) {
		html += "<div style='float:left'>"
		html += html_table_multiple_logs( "Reproducibility QC and Peak Detection Statistics (Irreproducible Discovery Rate)", \
							false, "idr", ["rep1"], [idr_qc] )
		html += html_help_idr( idr_thresh )
		html += "</div>"
	}

	for ( int i=1; i<=get_num_rep(); i++ ) {
		for ( int j=i+1; j<=get_num_rep(); j++ ) {
			if ( idr_tr_png.hasKey("$i,$j") ) \
				html += html_img( idr_tr_png{"$i,$j"}, 800, "true reps (rep$i-rep$j)" ) + "&nbsp"
		}
	}
	if ( idr_ppr_png != "" ) html += html_img( idr_ppr_png, 800, "pooled pseudo-reps" ) + "&nbsp"
	for ( int i=1; i<=get_num_rep(); i++ ) {
		if ( !true_rep ) {
			if ( idr_pr_png.hasKey(i) ) \
				html += html_img( idr_pr_png{i}, 800, "rep$i pseudo-reps" ) + "&nbsp"
		}
	}

	html += "</div><br>"
	return html
}

string html_chipseq_tracks() {
	if ( no_browser_tracks ) return ""

	string[] trk_files, trk_types, trk_names, trk_colors
	string color

	for (int rep=1; rep<=get_num_rep(); rep++) {
		group := get_group_name( 0, rep )
		color = get_predefined_rgb_str( rep )
		if ( bam.hasKey(group) )      { trk_types += "bam"; trk_names += "$title bam ($group)"; trk_colors += color; trk_files += bam{group} }
	}
	color = get_predefined_rgb_str( 0 ) // color for pooled reps
	if ( pval_bigwig.hasKey( "pooled" ) ) { trk_types += "bigwig"; trk_names += "$title pval (pooled)"; trk_colors += color; trk_files += pval_bigwig{"pooled"} }
	if ( fc_bigwig.hasKey( "pooled" ) )   { trk_types += "bigwig"; trk_names += "$title fc (pooled)";   trk_colors += color; trk_files += fc_bigwig{"pooled"}   }
	for (int rep=1; rep<=get_num_rep(); rep++) {
		color = get_predefined_rgb_str( rep )
		if ( pval_bigwig.hasKey( "rep$rep" ) ) { trk_types += "bigwig"; trk_names += "$title pval (rep$rep)"; trk_colors += color; trk_files += pval_bigwig{"rep$rep"} }
		if ( fc_bigwig.hasKey( "rep$rep" ) )   { trk_types += "bigwig"; trk_names += "$title fc (rep$rep)"; trk_colors += color;   trk_files += fc_bigwig{"rep$rep"}   }
	}
	color = get_predefined_rgb_str( 0 ) // color for pooled reps
	// if ( is_histone_chipseq() ) {
	// 	if ( peak_overlap ) { trk_types += "hammock"; trk_names += "$title peak overlap"; trk_colors += color; trk_files += peak_to_hammock( peak_overlap ) }
	// 	if ( gpeak_overlap ) { trk_types += "hammock"; trk_names += "$title gpeak overlap"; trk_colors += color; trk_files += peak_to_hammock( gpeak_overlap ) }
	// }
	if ( peak_overlap_opt ) {trk_types += "hammock"; trk_names += "$title peak overlap (opt. set)"; trk_colors += color; trk_files += peak_to_hammock( peak_overlap_opt ) }
	if ( peak_overlap_consv ) {trk_types += "hammock"; trk_names += "$title peak overlap (cons. set)"; trk_colors += color; trk_files += peak_to_hammock( peak_overlap_consv ) }
	for (int rep=1; rep<=get_num_rep(); rep++) {
		color = get_predefined_rgb_str( rep )
		if ( peak_overlap_pr.hasKey(rep) ) {trk_types += "hammock"; trk_names += "$title peak overlap (rep$rep-pr)"; trk_colors += color; trk_files += peak_to_hammock( peak_overlap_pr{rep} ) }
	}
	if ( idr_opt ) {trk_types += "hammock"; trk_names += "$title peak idr (opt. set)"; trk_colors += color; trk_files += peak_to_hammock( _get_idr_peak_trk( idr_opt ) ) }
	if ( idr_consv ) {trk_types += "hammock"; trk_names += "$title peak idr (cons. set)"; trk_colors += color; trk_files += peak_to_hammock( _get_idr_peak_trk( idr_consv ) ) }
	for (int rep=1; rep<=get_num_rep(); rep++) {
		color = get_predefined_rgb_str( rep )
		if ( idr_pr.hasKey(rep) ) {trk_types += "hammock"; trk_names += "$title peak idr (rep$rep-pr)"; trk_colors += color; trk_files += peak_to_hammock( _get_idr_peak_trk( idr_pr{rep} ) ) }
	}

	html := html_epg_browser_viz( trk_files, trk_types, trk_names, trk_colors, species_browser )

	return html
}

void help() {

	if ( is_cmd_line_arg_empty() ) {
		printHelp()
		exit
	}
}

bool is_final_stage_bam() {

	return final_stage.toLower() == "bam"
}

bool is_final_stage_filt_bam() {

	return final_stage.toLower() == "filt_bam"
}

bool is_final_stage_tag() {

	return final_stage.toLower() == "tag" || final_stage.toLower() == "tagalign"
}

bool is_final_stage_xcor() {

	return final_stage.toLower() == "xcor"
}

bool is_final_stage_peak() {

	return final_stage.toLower() == "peak"
}

bool is_final_stage_idr() {

	return (final_stage.toLower() == "idr") || (final_stage.toLower() == "")
}

bool is_final_stage_before_peak() {

	return is_final_stage_bam() || is_final_stage_filt_bam() || is_final_stage_tag() || is_final_stage_xcor()
}

bool is_final_stage_after_xcor() {

	return is_final_stage_idr() || is_final_stage_peak()
}

bool is_TF_chipseq() {

	return type.toLower() == "tf"
}

bool is_histone_chipseq() {

	return type.toLower() == "histone"
}

bool peak_exists() {
	return peak.hasKey("$peak_caller,1")
}

void check_peak_caller_valid() {
	peak_caller = peak_caller.toLower()
	if ( 	peak_caller != "spp" && \
		peak_caller != "macs2" && \
		peak_caller != "peakseq" && \
		peak_caller != "gem" ) \
		error("Choose peak_caller from 'spp', 'macs2', 'peakseq' and 'gem'.")
}

void check_aligner_valid() {
	aligner = aligner.toLower()
	if ( aligner != "bwa" ) \
		error("Choose aligner 'bwa'!")
}
